         +-------------------------+
         | CS 140                  |
         | PROJECT 4: FILE SYSTEMS |
         | DESIGN DOCUMENT         |
         +-------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Devon Hinton <dhinton@stanford.edu>
Peter Hu <peterhu@stanford.edu>
Kai-Yuan Neo <kneo@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.


>> Describe briefly which parts of the assignment were implemented by
>> each member of your team. If some team members contributed significantly
>> more or less than others (e.g. 2x), indicate that here.

Devon Hinton: 1/3
Peter Hu: 1/3
Kai-Yuan Neo: 1/3

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

         INDEXED AND EXTENSIBLE FILES
         ============================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

1) #define DIRECT_BLOCKS 12
  To determine the number of direct blocks in an inode_disk
2) #define INDIRECT_BLOCKS 1
  To determine the number of indirect blocks in an inode_disk
3) #define DBLY_INDIRECT_BLOCKS 1
  To determine the number of dbly indirect blocks in an inode_disk

4)
struct inode_disk
{
  block_sector_t direct_blocks [DIRECT_BLOCKS];
  block_sector_t indirect_block;
  block_sector_t dual_indirect_block;
  .
  .
  .
  unint32_t unused[112]
}
  4a) direct_blocks
      Used by the inode_disk via the inode to access the sectors of a file. Specifically
      those in direct blocks.
  4b) indirect_block
      Used to access sectors of a file. It stores a disk sector number with BLOCK_SECTOR_SIZE /
      (block_sector_t) sector numbers of a file.
  4c) dual_indirect_block
      It is used to indirectly access sectors of a file. 

  4d) unint32_t unused[112] 
      Used to pad the inode_disk so that is the size of a disk sector.

5)
struct inode 
{   .
    .
    .
    struct lock lock
}
  5a) struct lock lock
      Used to sychronize writes of a file/inode. Acquired when a file is being 
      extended.

  6) static struct lock open_inode_lock
     Used to sychronize the list of open inodes.



>> A2: What is the maximum size of a file supported by your inode
>> structure?  Show your work.
  
  (DIRECT_BLOCKS * BLOCK_SECTOR_SIZE)
  512 * 12 +
  (INDIRECT_BLOCKS * (BLOCK_SECTOR_SIZE/sizeof(block_sector_t) * BLOCK_SECTOR_SIZE)
  1 * (512/4) * 512 +
  (DBLY_INDIRECT_BLOCKS) * (BLOCK_SECTOR_SIZE/sizeof(block_sector_t) * 
    INDIRECT_BLOCKS * (BLOCK_SECTOR_SIZE/sizeof(block_sector_t) * BLOCK_SECTOR_SIZE)
  512/4 * 1 (512/4) * 512
  =
  8460288 bytes 

---- SYNCHRONIZATION ----

>> A3: Explain how your code avoids a race if two processes attempt to
>> extend a file at the same time.

  One process will acquire the lock for the given inode first and
  then hold it until after it finishes extending the file. and writing
  to the file. Thus when the second file arrives it will see that the 
  file has been extend. It can overwrite some data with its own but
  this will prevent the inode from being extended twice.
  

>> A4: Suppose processes A and B both have file F open, both
>> positioned at end-of-file.  If A reads and B writes F at the same
>> time, A may read all, part, or none of what B writes.  However, A
>> may not read data other than what B writes, e.g. if B writes
>> nonzero data, A is not allowed to see all zeros.  Explain how your
>> code avoids this race.

  We do not update the length of the inode until the write is completed.
  Thus if A were attempt to read the file, A would not be able to see
  any data until after B had written. If A tried to read the data first,
  A would not be able to read any of the data past EOF.

>> A5: Explain how your synchronization design provides "fairness".
>> File access is "fair" if readers cannot indefinitely block writers
>> or vice versa.  That is, many processes reading from a file cannot
>> prevent forever another process from writing the file, and many
>> processes writing to a file cannot prevent another process forever
>> from reading the file.

  We allow a reader to see data that is not complete. One processes may
  read from anoterh even when the file is being written to at the same time.
  Thus we allow data to interleaved.The one exception is that two processes
  may not read the same sector from disk at the same time. This is done by 
  sychronization in the buffer cache. 

  This fairness is also enforced by the property that reads and writes of
  the cache can only happen at max BLOCK_SECTOR_SIZE size at a time. In between
  this reads, it is possible for an interrupt to occur and anotehr processes
  to read or write. This break up of reads or writes into multiple batches
  creates fairness and also data interleaving.

---- RATIONALE ----

>> A6: Is your inode structure a multilevel index?  If so, why did you
>> choose this particular combination of direct, indirect, and doubly
>> indirect blocks?  If not, why did you choose an alternative inode
>> structure, and what advantages and disadvantages does your
>> structure have, compared to a multilevel index?

  We chose to use a multilevel index. The combination we chose would allow
  for 8 MB files but also not force us to use doubly indirect blocks on files
  of moderate size. 

  The doubly indirect block by itself gurantees that we have enough space for 8MB.
  Indeed, it can store exactly 8MB. However, a file  containing only a single
  doubly indirect block would not give us the flexibltye we want.   

  We noticed that there is greater overhead as we go from direct -> indirect 
  -> doubly indirect blocks. Direct blocks need one sector number, indirect need
  two, and doubly indirect three. However, indirect and doubly indirect blocks 
  give us more flexiblity. If we wanted files to be max size 8MB with only direct
  blocks each disk_inode will need 16384 block_sector_t pointers or 65536 bytes of
  overhead. This is clearly not pratical for smaller files. Thus we chose this 
  combination to allow for low memory allocation of small files and the flexibilty 
  to extend our files as well.


          SUBDIRECTORIES
          ==============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* A single directory entry. */
struct dir_entry
  {
    block_sector_t inode_sector;        /* Sector number of header. */
    char name[NAME_MAX + 1];            /* Null terminated file name. */
    bool in_use;                        /* In use or free? */
    bool is_dir;                        /* directory or file? */
  };
We added is_dir to let the inode know if the file represented by this dir_entry
is a file or a directory.

---- ALGORITHMS ----

>> B2: Describe your code for traversing a user-specified path.  How
>> do traversals of absolute and relative paths differ?

Code for traversing a path is in the function get_lowest_dir in
filesys.c. Code for getting the filename at the end of the path is
in get_filename in filesys.c. We do not allow opening paths that end in
'/'.

Our code for traversing a user-specified path first preens off any
preceding '/'s. If the path begins with a '/', we open the root
directory as the upper dir. If not we open the current thread's pwd.
Then we make a copy of the path and use strtok to get each individual
token. We need to make a copy so that the user specified path is not
modified. With each token we open a subsequent directory and close the
preceding one. If at any point this fails, for example if the specified
token is not a directory belonging in the preceding one, the function
returns NULL. At the second last token, if the next token (pointed to
by save_ptr) is not followed by a '/', we will break and return the
directory enclosing the last element in the pathname.

Once we return the directory enclosing the lowest element, all of the
filesys functions that take a pathname can find the filename of the
file they wish to use with strrchr. This is done in get_filename.
If the path does not contain a '/', we simply use the path as the filename.
If the path does contain a '/', we return the char addr one after the '/'.

---- SYNCHRONIZATION ----

>> B4: How do you prevent races on directory entries?  For example,
>> only one of two simultaneous attempts to remove a single file
>> should succeed, as should only one of two simultaneous attempts to
>> create a file with the same name, and so on.

>> B5: Does your implementation allow a directory to be removed if it
>> is open by a process or if it is in use as a process's current
>> working directory?  If so, what happens to that process's future
>> file system operations?  If not, how do you prevent it?

We do not allow a directory to be removed if it is open by a process
or in use as a pwd. We check that it is open or used as a pwd with the
inode open count of the directory, which can be retrieved by our function
inode_get_open_cnt in inode.c. If the count is greater than 1 (because
we have opened the directory to check its open count), we return false.
This code is in dir_remove in directory.c.

---- RATIONALE ----

>> B6: Explain why you chose to represent the current directory of a
>> process the way you did.

We chose to represent the current directory of a process by storing
the sector number of the directory in processes' thread struct.
This gives us flexibility on when to open the directory.

In our initial implementation we stored struct dir *'s in the thread
struct, but this proved inconvenient because at the point when we wished
to open the directory for the initial and starter thread in thread_init
and thread_start, the file system had not yet been initialized.
Thus we decided to store the root sector for the initial thread instead
of a struct dir * for the root directory, due to inconvenience during
initialization.

It is never hard to get from a sector number to a directory. We need only
invoke the functions inode_open and dir_open to get the struct dir *
from a sector number.

           BUFFER CACHE
           ============

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

static struct list cache_list;
This list is used to keep track of elements in the cache.

static struct hash cache_hash;
This is used for constant lookup of elements in the cache.

static struct lock cache_lock;
This is used to synchronize the cache, and grabbed every time we are
searching for a cache entry.

static struct list evict_list; // incoming I/Os taken care of by ce->lock
This is the list used to synchronize outgoing I/O's. Any sectors
undergoing outgoing I/O are added to this list.

static int cache_size;
This is our way of storing the number of elements in our hash
without using list_size (linear) and in order to synchronize the
cache size. We call hash_remove and hash_insert when we wish the
size to be constant, so cannot use hash_size.

struct evict_entry {
  block_sector_t sector_num;
  struct list_elem elem;
  struct condition io_complete;
  int num_waiters;
};
This entry is stored in the evict_list. It stores the sector
numbers of elements that are currently being evicted, and the
condition io_complete is broadcasted upon I/O complete. The
evict_entry is deleted when there are no more waiters on it
after a block_write.

struct cache_entry {
  block_sector_t sector_num;
  struct list_elem l_elem;
  struct hash_elem h_elem;
  struct lock lock;
  bool dirty;
  bool pinned_cnt;
  char data[BLOCK_SECTOR_SIZE];
};

#define BLOCK_SECTOR_SIZE 512
This is for convenience sake, stores a BLOCK_SIZE.

#define MAX_CACHE_SIZE 64
This stores the MAX_CACHE_SIZE. We can only store at most 64 blocks
worth of data and metadata.

#define FLUSH_INTERVAL 3000
This defines the time we wait between flushing the cache. 3000
represents 30 seconds.
---- ALGORITHMS ----

>> C2: Describe how your cache replacement algorithm chooses a cache
>> block to evict.

>> C3: Describe your implementation of write-behind.

>> C4: Describe your implementation of read-ahead.

---- SYNCHRONIZATION ----

>> C5: When one process is actively reading or writing data in a
>> buffer cache block, how are other processes prevented from evicting
>> that block?

>> C6: During the eviction of a block from the cache, how are other
>> processes prevented from attempting to access the block?

---- RATIONALE ----

>> C7: Describe a file workload likely to benefit from buffer caching,
>> and workloads likely to benefit from read-ahead and write-behind.

         SURVEY QUESTIONS
         ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students in future quarters?

>> Any other comments?
