        +---------------------------+
        | CS 140                    |
        | PROJECT 3: VIRTUAL MEMORY |
        | DESIGN DOCUMENT           |
        +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Devon Hinton <dhinton@stanford.edu>
Peter Hu <peterhu@stanford.edu>
Kai-Yuan Neo <kneo@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Describe briefly which parts of the assignment were implemented by
>> each member of your team. If some team members contributed significantly
>> more or less than others (e.g. 2x), indicate that here.

Devon Hinton: 1/3
Peter Hu: 1/3
Kai-Yuan Neo: 1/3

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

      PAGE TABLE MANAGEMENT
      =====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

PAGE.H: 

enum page_loc {
  UNMAPPED = 0,     // unmapped to physical memory
  MAIN_MEMORY = 1,
  SWAP_DISK = 2
};

This tells our supplemental page table entry where in memory this page
currently resides.

enum page_type {
  _STACK = 0,
  _EXEC = 1,
  _FILE = 2
};

This tells our supplemental page table entry what type of memory this
page holds. It does not change while in the table.

struct sup_page_entry {
  void *upage;
  User virtual address. This is the key of our supplemental page table 
  entry. It is used to lookup the entry in the supplemental page table, 
  which is implemented using a hash table.

  struct hash_elem elem;
  This is a utility variable used to index into the supplementary page table
  that is implemented using a hash table.

  void *kpage;          // to access relevant entry in frame_table 
  This stores the current kernel virtual address of our virtual page, if any.
  If the page is NULL, the page does not currently reside in memory.
  We use this to index into our global frame table array.

  int page_loc;
  This tells our supplemental page table entry where in memory this page
  currently resides: UNMAPPED, MAIN_MEMORY, or SWAP_DISK.

  int page_type;
  This tells our supplemental page table entry what type of memory this
  page holds. It does not change while in the table.
  Types are _STACK, _EXEC, and _FILE. 

  int swap_index;
  This indicates the page index on swap disk where this page currently resides.
  Its value is -1 when the page is not on swap.

  int page_read_bytes;  // only applies to executables and files
  This indicates how many bytes of this page we wish to read, starting at
  file_offset bytes into our file. It applies for executables and files, 
  because we wish to zero out PGSIZE - page_read_bytes bytes at the end of the
  page. Its value is -1 when it represents a stack page.

  struct file *file;
  This stores the pointer to the file struct from which the data can be read.
  This file pointer is used for executables and files. When the data is not
  writable we will discard it when evicting, and the file * will be used to 
  read in the appropriate data again when mapping.

  int file_offset;
  Goes in tandem with the file *, this tells us from which byte in the file we
  need to start reading. This value must be page aligned.

  bool zeroed;
  This is used when loading a page to determine when we need a page that is initialized
  to zero when palloc'ed. It is also used to detect when we do not wish to write a page
  to swap. If the page is read to, the zeroed bit is set to false.

  bool writable;
  This bool does not change throughout the lifetime of this supplemental page table
  entry. Stack pages are always writable. Executable and file pages are writable
  depending on the file permissions passed in during load and open file respectively.

  bool written;
  This bool is used to supplement pagedir_is_dirty. We found there were some errors when
  a page was written to swap, written back to memory, then back to swap again. For some
  reason when written back to memory the dirty bit was removed, resulting in the written
  data being removed the next time it was evicted.

  struct lock lock;
  This lock locks the supplemental page table entry. It prevents any accesses to the
  particular entry while it is in an inconsistent state. In particular, this is helpful
  when doing I/Os, because it prevents any accessing threads from attempting to access
  this data during the I/O.
};

FRAME.H:

struct frame_entry {
  struct lock lock;
  This is a fine lock for the frame entry so that no thread can access the frame entry
  in an inconsistent / corrupted state. It is acquired after acquiring the frame table
  lock and held throughout the duration of any modifications to the frame.

  struct thread *thread;  // to access the thread's pagedir
  This holds a pointer to the current owner thread of this frame. It is primarily used 
  when we wish to see attributes of this page's page directory entry, utilized in tandem
  with upage below. When a thread exits or this frame because free, the thread pointer is
  set to NULL.

  void *upage;            // to access the entry in thread's pagedir
  This holds the current user virtual address belonging to the owner thread of this frame.
  It is used in tandem with the pointer to the owner thread to do lookups in the thread's
  page directory for accesss and dirty bits.

  bool pinned;         // If true, pinned by the kernel, do not evict
  This is a flag that the kernel sets in system calls to prevent pages from being evicted
  just after they have been moved into main memory. The pinning procedure is necessary to
  prevent page faulting in the kernel, because in the kernel we check and map memory into 
  physical memory prior to dereferencing it.
};

FRAME.C:

#define FREE_PAGES_START_OFFSET 1024 * 1024
This is a macro we use to keep track of the initial offset that the program uses in
palloc.c as the start of virtual memory. We decided to use this offset to do 
kpage-frame_entry translations in frame.c instead of palloc.c to keep the frame members 
local to the frame files.

static struct frame_entry *frame_table;
The frame_table is the data structure responsible for representing main memory and which
pages currently reside in it. It is implemented using an array. It is mainly used for the 
process of eviction, where we iterate over the frame table and evict frames that have not 
been accessed since the last iteration. It's entries are frame_entries.

static struct lock frame_table_lock;  // only used in clock algorithm
static int num_user_pages;            // only used in clock algorithm
static int num_kernel_pages;          // used in getting frame_entry

struct thread {
    ...
    ...
    ...

    struct lock sup_page_table_lock;
    This lock locks the entire supplemental page table. It is used exclusively to lock
    the page table while we retrieve the supplemental page table entry, so that we
    do not get inconsistent behavior with the hash table, nor have race conditions
    between two threads trying to access an entry.

    struct hash *sup_page_table;
    The supplemental page table (SPT)  is stored in a hash table implementation. The keys
    to this hash table are user virtual addressses, and they are stored inside the
    values, which are struct sup_page_entrys. The SPT is the core of our virtual 
    memory system. Every access to virtual memory goes through the SPT.

    void *esp;
    This is set in the system call handler in order to verify attempts at stack growth
    without passing the esp parameter in between all syscall functions. It is used to 
    check whether a memory address is attempting to grow the stack.

    struct lock exit_lock; // used to synchronize eviction during exit 
    The exit lock is used to synchronize eviction during exit. It prevents the eviction
    algorithm from selecting a frame to evict just as the thread that owns that frame is
    exiting, thereby clearing the frame just before we try to write the data to swap.
    Using the lock allows the eviction algorithm to skip over frames when they cannot
    acquire the owner thread's exit lock.
};


---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

We allocate our frame table in frame_init() which is called in init.c. It remains in
kernel memory for the duration of the operating system's run. To locate the frame that
contains the data of a given page we always use the function kpage_to_frame_entry, which
takes in a kpage as a parameter and translates that with math and the threads/vaddr.h
function vtop to a frame index, before returning the frame entry corresponding to that
index. 

The math works as follows: we first subtract PHYS_BASE through vtop, then subtract the
space required by kernel pages, then subtract the FREE_PAGES_START_OFFSET used during
the palloc_init function in palloc.c. Dividing the result by PGSIZE yields the
corresponding index of our frame table.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We avoid this issue by always referencing accessed and dirty bits from the user virtual
address. Every time we wish to see if a page is accessed or dirty, we look up the
corresponding entry in the owner thread's page directory with pagedir_is_accessed
or pagedir_is_dirty functions, using the owner thread's page directory and user virtual
address as parameters.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

When two user processes both need a new frame at the same time, we avoid such races
with the coarse frame_table_lock. All processes that need a new frame will go through the
choke point of frame_add, which first acquires the frame_table_lock until it secures a
frame that is free or has been freed through eviction. Thus no two processes can be
searching for a free frame at the same time. Once one processes selects a frame
and has grabbed the fine frame_entry lock, it immediately releases the frame_table_lock
to maximize concurrency.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

We chose to implement the supplemental page table (SPT) with a hash table, and the frame 
table with an array. The hash table is useful for looking up items in theoretically
constant time based on a key. In practice the implementation may be a little slower due
to chaining. The array is most useful for fast indexing, since all entries in the array 
correspond to contiguous pages in kernel virtual memory. An additional benefit of the array
is easy iteration with a for loop.

When a process page_faults, it is trying to dereference some user virtual memory address,
referred to in our code with "upage". Using upages as keys, we can take these page faults
and in constant time lookup all relevant data regarding this page. This is the power of
the SPT. If the page is currently not in memory, the kpage value of the SPT entry will be 
NULL. If the page needs to be brought into memory, the process will run through our 
frame_add mechanism which attempts to palloc a page and bring that page into physical 
memory. Once a page is palloc'ed or a frame is evicted, the relevant kernel virtual 
address, referred to in our code with "kpage", will then be stored in the SPT entry.

Our SPT's efficiency comes from its constant lookup based on upage.
Our frame table can both be indexed in constant time and iterated in linear time.


           PAGING TO AND FROM DISK
           =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

SWAP.H:

#define SECTORS_PER_PAGE 8
This is used in our swap_read_page and swap_write_page functions to convert from the
bits in the bitmap that each represent a page to the sectors on disk. Whenever we read
and write from disk we do it in for loops that go SECTORS_PER_PAGE iterations, because
the block_read and block_write functions only support sector-size reading and writing
functionalities.

SWAP.C:

struct bitmap *swap_table;
The swap table is used to identify which pages on swap disk have currently been used. It
is stored as a bitmap because we only need to know which pages on swap disk currently store
data. Each bit in the table represents a page of data.

struct lock swap_table_lock;
The swap table lock is used whenever performing bitmap operations on the swap_table.
This is used to prevent corrupting the bitmap and leaving it in an inconsistent state,
because bitmaps do not support internal concurrency. It is particularly necessary when
performing bitmap_scan_and_flip to find the next swap_index, so no two processes will try
and use the same swap_index.

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

       MEMORY MAPPED FILES
       ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

         SURVEY QUESTIONS
         ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
